<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Anwenderdokumentation 1 ss11-g07</title>
  <style type="text/css">
    body {
    width: 800;
    margin: 0 auto;
    }
  </style>
</head>

<body>

<div align="Center">
<h3><a name="Benutzer_Doku"></a><strong>Anwenderdokumentation zum Projekt Nr. 1 der Gruppe 7 (ss11-g07)</strong></h3>
<i>Tutor: Steffen Bauereiss</i><br/>
<i>Autor: Maximilian Staab</i><br/>
</div>
<ul>
<li>
  <a href="#kurzbeschreibung">Kurzbeschreibung</a>
</li>
<li>
  <a href="#abhaengigkeiten">Abhängigkeiten</a>
</li>
<li>
  <a href="#eingabe">Eingabe</a>
</li>
<li>
  <a href="#ausgabe">Ausgabe</a>
</li>
</ul>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="kurzbeschreibung">Kurzbeschreibung</a></h4>
<p>Das vorliegende VHDL-System konvertiert eine Binärzahl mit 17 Stellen in eine BCD-Zahl mit 5 x 4 Stellen. Der Definitionsbereich ist [0, 99999].</p>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="abhaengigkeiten">Abhängigkeiten</a></h4><p>
  Um die Schaltung <code>BINBCD</code> testen zu können, benötigt man folgende Software:
<ul>
  <li>GHDL (ghdl) - Version 0.29;</li>
  <li>GTKWave Analyzer (gtkwave) - Version 3.3.19;</li>
  <li>GNU Make (make) - Version 3.81 (optional).</li>
</ul>
  Als Referenzplattform dient eine aktuelle Linuxdistribution (Ubuntu 11.04 x86-64) mit der o. g. Software.</p>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="eingabe">Eingabe</a></h4><p>
Die Eingabe der Schaltung kann in der Testbench (<code>testbench.vhd</code>) verändert werden. Zu Beginn der Architecture <code>BINBCD_test</code> wird der Eingabeparameter <code>bin_input</code> definiert, welcher ein 17-Bit-langer std_logic_vector (MSB first) ist. Alle 17 Bits dieses Vektors können nach Belieben verändert werden.<br/>
Beispiel:<br/>
<code><pre>    SIGNAL bin_input: std_logic_vector(16 DOWNTO 0) := "00000001101000100";     -- 00836</pre></code><br/>
Nach jeder Änderung muss die Schaltung neu analysiert, elaboriert, gestestet und das Ergebnis in GTKWave angezeigt werden.</p>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="ausgabe">Ausgabe</a></h4><p>
  Automatisch: Im Verzeichnis der Implementierung gibt es ein <code>Makefile</code>, welches benutzt werden kann, um die Schaltung zu testen. Gibt man in einem Terminal im Implementierungsverzeichnis den Befehl <code>make</code> ein, so wird die Schaltung automatisch analysiert, elaboriert und getestet; das Ergebnis wird in GTKWave angezeigt.<br/><br/>

  Manuell: Ist <code>make</code> nicht vorhanden, so kann die Schaltung manuell getestet werden. Dazu müssen in einem Terminal im Implementierungsverzeichnis folgende Befehle eingegeben werden:<br/></div>
<ul>
  <li><code>ghdl -a implementierung1.vhd testbench.vhd</code></li>
  <li><code>ghdl -e testbench</code></li>
  <li><code>./testbench --stop-time=20000ms --vcd=testbench.w</code></li>
  <li><code>gtkwave testbench.w</code></li>
</ul>
  Der erste Befehl analysiert dabei die eigentliche VHDL-Schaltung (<code>implementierung1.vhd</code>) und dessen Testbench (<code>testbench.vhd</code>); der zweite Befehl elaboriert die zuvor analysierte Schaltung; der dritte Befehl startet einen 20-sekündigen Testdurchlauf; der vierte Befehl zeigt diesen Testdurchlauf in GTKWave an.</br></br>

<u>Ausgabewerte auslesen</u>: Nachdem GTKWave die Testdatei gelesen hat, kann man die interessanten Signale aus der Liste in die Anzeige einfügen, den erwünschten Zeitpunkt anklicken und den aktuellen Wert auslesen. Die Ausgabezahl steht im aus den Vektoren <code>einer</code>, <code>zehner</code>, <code>hunderter</code>, <code>tausender</code> und <code>zehntausender</code> zusammengesetzten Vektor (MSB first). Das OF-Flag steht in <code>overflow</code>. Alle relevanten Signale sind nach ca. 1,7 s errechnet.<br/>
Beispiel:
<img src=testbench.w.png alt="Beispielscreenshot" title="Beispielscreenshot" />
</p>

</body>
</html>
