<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Spezifikation ss11-g07</title>
</head>
<body>
<div align="Center">
<h3><a name="Spezifikation"></a><strong>Spezifikation zum Projekt Nr. 2 der Gruppe 7 (ss11-g07)</strong></h3>
<i>Tutor: Steffen Bauereiss</i><br>
</div>

<ul>

<li><a href="#Kurzbeschreibung">Kurzbeschreibung</a></li>
<li><a href="#Alternative1">Alternative 1</a></li>
<li><a href="#Alternative2">Alternative 2</a></li>
<li><a href="#Bewertung">Bewertung der Alternativen</a></li>
<li><a href="#Entscheidung">Implementierungsentscheidung</a></li>
</ul>
<br>

<hr width="100%" size="1">
<h4><a name="Kurzbeschreibung">Kurzbeschreibung</a></h4>
<p>
Es ist eine Funktion DGBMV zu entwickeln, welche Matrix-Vektor-Operationen in Abhängigkeit von TRANS durchführt. Wenn TRANS='N' oder 'n', wird die folgende Formel verwendet<br/><br/>
<code>Y := ALPHA * A * X + BETA * Y</code>.<br/><br/>
Wenn TRANS='T' oder 't' oder 'C' oder 'c', wird die folgende Formel verwendet<br/><br/>
<code>Y := ALPHA * A' * X + BETA * Y</code>.<br/><br/>
ALPHA, BETA seien Skalare; X, Y seien Vektoren; A sei eine Matrix; A' sei transponiertes A.
</p>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="Alternative1">Alternative 1: Normalform</a></h4>
<p>
A, X und Y werden jeweils als A2, X2 und Y2 gesichert. Die Matrix A in Bandspeicherform wird in eine NxM-Bandmatrix in Normalform umgewandelt. Die Vektoren X sowie Y werden jeweils aus den inkrementierten Arrays X bzw. Y extrahiert und als X bzw. Y gespeichert.<br/><br/>

<ol>
<li>Nun wird eine Skalarmultiplikation der Matrix A mit dem Skalar ALPHA sowie des Vektors Y mit dem Skalar BETA durchgeführt und als AA bzw. YB gespeichert.</li>
<li>Weiter wird eine Matrixmultiplikation der Matrix AA mit dem Vektor X durchgeführt und das Ergebnis als AAX gespeichert.</li>
<li>Nachfolgend findet eine Vektoraddition der Vektoren AAX und YB statt, deren Ergebnis als AAXYB gespeichert wird.</li>
<li>Nun wird der Vektor AAXYB in Y2 eingesetzt und als inkrementiertes Array Y zurückgegeben.</li>
</ol>
<br/><br/>
Skalarmultiplikation<br/>
AA: aa<sub>ij</sub> = (a<sub>ij</sub> &middot; ALPHA)<sub>i=1..M; j=1..N</sub>
<br/>
YB: yb<sub>i</sub> = (y<sub>i</sub> &middot; BETA)<sub>i=1..n</sub>
<br/><br/>

Matrix-Vektor-Multiplikation<br/>
<table><tr>
<td>AAX: aax<sub>i</sub> = </td><td><sub>&nbsp;N</sub><br/><font size="+3">&sum;</font><br/><sup>k=1</sup></td><td>(a<sub>ik</sub> &middot; x<sub>k</sub>)<sub>i=1..M</sub></td>
</tr></table>
<br/>

Vektoraddition<br/>
AAXYB: aaxyb<sub>i</sub> = (aax<sub>i</sub> + yb<sub>i</sub>)<sub>i=1..N</sub>
</p>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="Alternative2">Alternative 2: Bin-Dec-BCD Algorithmus</a></h4>
<p>
Diese Alternative sieht es vor, dass die Eingabe zuerst (mit Hilfe einer binären Konstanten: 11000011010011111<sub>2</sub> = 99999<sub>10</sub>) auf ihre Gültigkeit überprüft wird. Liegt die Eingabe im Definitionsbereich, wird sie nach folgendem Schema in eine dezimale Zahl umgewandelt (beginnend mit dem niedrigstwertige Bit, LSB):
<ol>
<li>Initialisiere eine Variable "dec" mit 0. Diese wird am Ende die dezimale Zahl enthalten.</li>
<li>Multipliziere die Wertigkeit der aktuellen Stelle (2<sup>0</sup>, 2<sup>1</sup>, ..., 2<sup>16</sup>) mit der Ziffer der aktuellen Stelle (1,0).</li>
<li>Addiere das Produkt aus Schritt 2 zu dec.</li>
<li>Wiederhole dieses Schema (ab Schritt 2) für alle Stellen der Binären Eingabe (17x).</li>
</ol>
Nun, da die Eingabe in dezimaler Form vorliegt, wird jede der (max. 5) Stellen mit Hilfe einer Lookup-Tabelle, welche die Werte von 0-9 je in Dezimal und Binär enthält, in Binär an den entsprechenden Ausgang gelegt.
</p>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="Bewertung">Bewertung der Alternativen</a></h4>
<p>
Die Alternative 1 (A1) scheint effizienter zu sein, da hier nur Schiebe und Additions Operationen benötigt werden, wogegen Alternative 2 (A2) Additions und Multiplikations Operationen benötigt. Die Multiplikation würde die Hardware unnötig komplex machen.<br/>
Weiterhin wird die Eingabe bei A2 zwei mal in ein anderes Zahlensystem umgerechnet, was unnötige Rechenschritte darstellt. Bei A1 kann die binäre Eingabe innerhalb einer Schleife, welche über den Vektor läuft, berechnet werden.
</p>
<br/>
<br/>

<hr width="100%" size="1">
<h4><a name="Entscheidung">Implementierungsentscheidung</a></h4>
<p>
Wir haben uns für den Double-Dabble Algorithmus aus Alternative 1 entschieden, da die oben genannten Vorteile der Alternative 1 überwiegen.
</p>

</body>
</html>

